{"ast":null,"code":"import React, { useContext } from 'react';\nvar UntabbableContext = React.createContext(false);\n\n/**\n * A wrapper that marks a section of the component tree as unreachable via the\n * <kbd>Tab</kbd> key. It renders no element on its own and must contain a\n * single element child. By itself it does nothing, but descendants using the\n * `useTabIndex` hook will receive `-1` if there is an active Untabbable\n * ancestor.\n *\n * If you need to toggle tabbability back on, set the `active` prop to false.\n * This is preferable to conditionally inserting the Untabbable parent since it\n * keeps the component tree structure the same, avoiding remounts.\n */\n\nfunction Untabbable(_ref) {\n  let {\n    // Whether this Untabbable is actually active, overriding the output of\n    // `useTabIndex`.\n    active = true,\n    // Context provider children.\n    children,\n    // Whether this Untabbable should ignore ancestor Untabbable state. This is\n    // rarely what you want, unless you are setting up something with modal\n    // elements. In that case, you may want all elements behind the modal to\n    // become untabbable, but the modal element is likely to have that same\n    // Untabbable context as its ancestor (since context is preserved across\n    // portals). Thus, the content of the modal component itself should be wrapped\n    // in an Untabbable with the `reset` prop.\n    reset = false\n  } = _ref;\n  const anyParentActive = useContext(UntabbableContext); // Explicitly force value to Boolean, since users often rely on truthiness\n  // shorthand like `active={object}`, `active={array.length}`, etc.\n\n  const value = Boolean(reset ? active : active || anyParentActive);\n  return React.createElement(UntabbableContext.Provider, {\n    value: value\n  }, children);\n}\nfunction useTabIndex(tabIndex) {\n  const isUntabbable = useContext(UntabbableContext);\n  return isUntabbable ? -1 : tabIndex;\n}\nexport { Untabbable, UntabbableContext, useTabIndex };","map":{"version":3,"names":["React","useContext","UntabbableContext","createContext","Untabbable","_ref","active","children","reset","anyParentActive","value","Boolean","createElement","Provider","useTabIndex","tabIndex","isUntabbable"],"sources":["D:/Personal/Mi Perfil/Escritorio/interfaces/SegundaEntrega/app/node_modules/react-tabindex/dist/index.esm.js"],"sourcesContent":["import React, { useContext } from 'react';\n\nvar UntabbableContext = React.createContext(false);\n\n/**\n * A wrapper that marks a section of the component tree as unreachable via the\n * <kbd>Tab</kbd> key. It renders no element on its own and must contain a\n * single element child. By itself it does nothing, but descendants using the\n * `useTabIndex` hook will receive `-1` if there is an active Untabbable\n * ancestor.\n *\n * If you need to toggle tabbability back on, set the `active` prop to false.\n * This is preferable to conditionally inserting the Untabbable parent since it\n * keeps the component tree structure the same, avoiding remounts.\n */\n\nfunction Untabbable({\n  // Whether this Untabbable is actually active, overriding the output of\n  // `useTabIndex`.\n  active = true,\n  // Context provider children.\n  children,\n  // Whether this Untabbable should ignore ancestor Untabbable state. This is\n  // rarely what you want, unless you are setting up something with modal\n  // elements. In that case, you may want all elements behind the modal to\n  // become untabbable, but the modal element is likely to have that same\n  // Untabbable context as its ancestor (since context is preserved across\n  // portals). Thus, the content of the modal component itself should be wrapped\n  // in an Untabbable with the `reset` prop.\n  reset = false\n}) {\n  const anyParentActive = useContext(UntabbableContext); // Explicitly force value to Boolean, since users often rely on truthiness\n  // shorthand like `active={object}`, `active={array.length}`, etc.\n\n  const value = Boolean(reset ? active : active || anyParentActive);\n  return React.createElement(UntabbableContext.Provider, {\n    value: value\n  }, children);\n}\n\nfunction useTabIndex(tabIndex) {\n  const isUntabbable = useContext(UntabbableContext);\n  return isUntabbable ? -1 : tabIndex;\n}\n\nexport { Untabbable, UntabbableContext, useTabIndex };\n"],"mappings":"AAAA,OAAOA,KAAK,IAAIC,UAAU,QAAQ,OAAO;AAEzC,IAAIC,iBAAiB,GAAGF,KAAK,CAACG,aAAa,CAAC,KAAK,CAAC;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,UAAUA,CAAAC,IAAA,EAchB;EAAA,IAdiB;IAClB;IACA;IACAC,MAAM,GAAG,IAAI;IACb;IACAC,QAAQ;IACR;IACA;IACA;IACA;IACA;IACA;IACA;IACAC,KAAK,GAAG;EACV,CAAC,GAAAH,IAAA;EACC,MAAMI,eAAe,GAAGR,UAAU,CAACC,iBAAiB,CAAC,CAAC,CAAC;EACvD;;EAEA,MAAMQ,KAAK,GAAGC,OAAO,CAACH,KAAK,GAAGF,MAAM,GAAGA,MAAM,IAAIG,eAAe,CAAC;EACjE,OAAOT,KAAK,CAACY,aAAa,CAACV,iBAAiB,CAACW,QAAQ,EAAE;IACrDH,KAAK,EAAEA;EACT,CAAC,EAAEH,QAAQ,CAAC;AACd;AAEA,SAASO,WAAWA,CAACC,QAAQ,EAAE;EAC7B,MAAMC,YAAY,GAAGf,UAAU,CAACC,iBAAiB,CAAC;EAClD,OAAOc,YAAY,GAAG,CAAC,CAAC,GAAGD,QAAQ;AACrC;AAEA,SAASX,UAAU,EAAEF,iBAAiB,EAAEY,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}