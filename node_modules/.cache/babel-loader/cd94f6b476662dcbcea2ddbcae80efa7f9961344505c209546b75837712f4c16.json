{"ast":null,"code":"import React, { useContext } from 'react';\nvar UntabbableContext = React.createContext(false);\n\n/**\r\n * A wrapper that marks a section of the component tree as unreachable via the\r\n * <kbd>Tab</kbd> key. It renders no element on its own and must contain a\r\n * single element child. By itself it does nothing, but descendants using the\r\n * `useTabIndex` hook will receive `-1` if there is an active Untabbable\r\n * ancestor.\r\n *\r\n * If you need to toggle tabbability back on, set the `active` prop to false.\r\n * This is preferable to conditionally inserting the Untabbable parent since it\r\n * keeps the component tree structure the same, avoiding remounts.\r\n */\n\nfunction Untabbable(_ref) {\n  let {\n    // Whether this Untabbable is actually active, overriding the output of\n    // `useTabIndex`.\n    active = true,\n    // Context provider children.\n    children,\n    // Whether this Untabbable should ignore ancestor Untabbable state. This is\n    // rarely what you want, unless you are setting up something with modal\n    // elements. In that case, you may want all elements behind the modal to\n    // become untabbable, but the modal element is likely to have that same\n    // Untabbable context as its ancestor (since context is preserved across\n    // portals). Thus, the content of the modal component itself should be wrapped\n    // in an Untabbable with the `reset` prop.\n    reset = false\n  } = _ref;\n  const anyParentActive = useContext(UntabbableContext); // Explicitly force value to Boolean, since users often rely on truthiness\n  // shorthand like `active={object}`, `active={array.length}`, etc.\n\n  const value = Boolean(reset ? active : active || anyParentActive);\n  return React.createElement(UntabbableContext.Provider, {\n    value: value\n  }, children);\n}\nfunction useTabIndex(tabIndex) {\n  const isUntabbable = useContext(UntabbableContext);\n  return isUntabbable ? -1 : tabIndex;\n}\nexport { Untabbable, UntabbableContext, useTabIndex };","map":{"version":3,"names":["React","useContext","UntabbableContext","createContext","Untabbable","_ref","active","children","reset","anyParentActive","value","Boolean","createElement","Provider","useTabIndex","tabIndex","isUntabbable"],"sources":["C:/Users/lnv_0/OneDrive/Documentos/CARRERA/TERCERO/2CUATRI/INTERFACES_USUARIO/PROYECTO/DeployRecetapp/RecetApp/node_modules/react-tabindex/dist/index.esm.js"],"sourcesContent":["import React, { useContext } from 'react';\r\n\r\nvar UntabbableContext = React.createContext(false);\r\n\r\n/**\r\n * A wrapper that marks a section of the component tree as unreachable via the\r\n * <kbd>Tab</kbd> key. It renders no element on its own and must contain a\r\n * single element child. By itself it does nothing, but descendants using the\r\n * `useTabIndex` hook will receive `-1` if there is an active Untabbable\r\n * ancestor.\r\n *\r\n * If you need to toggle tabbability back on, set the `active` prop to false.\r\n * This is preferable to conditionally inserting the Untabbable parent since it\r\n * keeps the component tree structure the same, avoiding remounts.\r\n */\r\n\r\nfunction Untabbable({\r\n  // Whether this Untabbable is actually active, overriding the output of\r\n  // `useTabIndex`.\r\n  active = true,\r\n  // Context provider children.\r\n  children,\r\n  // Whether this Untabbable should ignore ancestor Untabbable state. This is\r\n  // rarely what you want, unless you are setting up something with modal\r\n  // elements. In that case, you may want all elements behind the modal to\r\n  // become untabbable, but the modal element is likely to have that same\r\n  // Untabbable context as its ancestor (since context is preserved across\r\n  // portals). Thus, the content of the modal component itself should be wrapped\r\n  // in an Untabbable with the `reset` prop.\r\n  reset = false\r\n}) {\r\n  const anyParentActive = useContext(UntabbableContext); // Explicitly force value to Boolean, since users often rely on truthiness\r\n  // shorthand like `active={object}`, `active={array.length}`, etc.\r\n\r\n  const value = Boolean(reset ? active : active || anyParentActive);\r\n  return React.createElement(UntabbableContext.Provider, {\r\n    value: value\r\n  }, children);\r\n}\r\n\r\nfunction useTabIndex(tabIndex) {\r\n  const isUntabbable = useContext(UntabbableContext);\r\n  return isUntabbable ? -1 : tabIndex;\r\n}\r\n\r\nexport { Untabbable, UntabbableContext, useTabIndex };\r\n"],"mappings":"AAAA,OAAOA,KAAK,IAAIC,UAAU,QAAQ,OAAO;AAEzC,IAAIC,iBAAiB,GAAGF,KAAK,CAACG,aAAa,CAAC,KAAK,CAAC;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,UAAUA,CAAAC,IAAA,EAchB;EAAA,IAdiB;IAClB;IACA;IACAC,MAAM,GAAG,IAAI;IACb;IACAC,QAAQ;IACR;IACA;IACA;IACA;IACA;IACA;IACA;IACAC,KAAK,GAAG;EACV,CAAC,GAAAH,IAAA;EACC,MAAMI,eAAe,GAAGR,UAAU,CAACC,iBAAiB,CAAC,CAAC,CAAC;EACvD;;EAEA,MAAMQ,KAAK,GAAGC,OAAO,CAACH,KAAK,GAAGF,MAAM,GAAGA,MAAM,IAAIG,eAAe,CAAC;EACjE,OAAOT,KAAK,CAACY,aAAa,CAACV,iBAAiB,CAACW,QAAQ,EAAE;IACrDH,KAAK,EAAEA;EACT,CAAC,EAAEH,QAAQ,CAAC;AACd;AAEA,SAASO,WAAWA,CAACC,QAAQ,EAAE;EAC7B,MAAMC,YAAY,GAAGf,UAAU,CAACC,iBAAiB,CAAC;EAClD,OAAOc,YAAY,GAAG,CAAC,CAAC,GAAGD,QAAQ;AACrC;AAEA,SAASX,UAAU,EAAEF,iBAAiB,EAAEY,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}